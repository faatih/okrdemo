# Story 1.2: Database Schema & Migrations

## Status
Draft

## Story
**As a** developer,
**I want** complete Drizzle schema definitions for teams, users, quarters, objectives, keyResults, checkIns, and imports,
**so that** the application has a fully typed, relational database foundation to support OKR workflows.

## Acceptance Criteria
1. `db/schema.ts` defines all tables per PRD Technical Assumptions: teams, users, quarters, objectives, keyResults, checkIns, imports
2. Schema includes unused `organizationId` columns on teams, users, quarters, objectives (for future multi-tenant migration)
3. Foreign key relationships defined: users→teams, objectives→quarters/teams/users, keyResults→objectives, checkIns→keyResults/users
4. Unit types enumerated: %, pp, $, # (string column with validation)
5. Direction types enumerated: up, down (string column)
6. Confidence types enumerated: 0=Red, 1=Amber, 2=Green (integer column)
7. Drizzle migrations generated and applied to development database
8. Seed script creates 2 teams, 5 users, 1 quarter (2025-Q1), and sample airline S&M data (3 Objectives, 10 KRs) per FR17
9. Database connection verified via simple query in health check endpoint

## Tasks / Subtasks

- [ ] **Replace existing schema with RunwayOKR schema** (AC: 1, 2, 3, 4, 5, 6)
  - [ ] Back up existing `db/schema.ts` (Better Auth tables)
  - [ ] Create new schema with all RunwayOKR tables (see Dev Notes for complete schema)
  - [ ] Add Better Auth tables back to schema (from starter pack: user, session, account, verification)
  - [ ] Define `team` table with organizationId for multi-tenant Phase 2
  - [ ] Define `okrUser` table (separate from Better Auth user) with teamId FK and organizationId
  - [ ] Define `quarter` table with date fields and organizationId
  - [ ] Define `objective` table with FKs to team, quarter, okrUser (owner), and organizationId
  - [ ] Define `keyResult` table with FK to objective, okrUser (owner), unit/direction enums, numeric values
  - [ ] Define `checkIn` table with FK to keyResult, okrUser (createdBy), confidence enum
  - [ ] Define `importRecord` table with metadata jsonb field
  - [ ] Add performance indexes (see Dev Notes for index definitions)

- [ ] **Create TypeScript type exports from schema** (AC: 1)
  - [ ] Export Drizzle-inferred types in `types/database.ts` or `db/types.ts`
  - [ ] Create convenience type aliases: `Unit`, `Direction`, `ConfidenceLevel`
  - [ ] Ensure types are available for import in API routes and components

- [ ] **Generate and apply Drizzle migrations** (AC: 7)
  - [ ] Run `npx drizzle-kit generate:pg` to create migration files
  - [ ] Review generated SQL migration in `drizzle/` directory
  - [ ] Run `npx drizzle-kit push:pg` to apply migrations to development database
  - [ ] Verify all tables created successfully in Neon dashboard or via SQL query
  - [ ] Commit migration files to Git

- [ ] **Create comprehensive seed script** (AC: 8)
  - [ ] Create `db/seed.ts` file with seed data function
  - [ ] Seed 2 teams: "Direct Channel Sales", "Corporate Sales"
  - [ ] Seed 5 users: 2 per team + 1 executive (see Dev Notes for user examples)
  - [ ] Seed 1 quarter: "2025-Q1" with dates 2025-01-01 to 2025-03-31
  - [ ] Seed 3 Objectives from airline S&M templates (FR17):
    - "Grow Direct Channel Revenue" (Direct Channel Sales team)
    - "Expand Corporate Sales in APAC" (Corporate Sales team)
    - "Increase Loyalty Co-brand Revenue" (Direct Channel Sales team)
  - [ ] Seed 10 Key Results across the 3 Objectives with realistic airline metrics
  - [ ] Add 2-3 initial check-ins per KR to populate sparkline data
  - [ ] Create npm script `"seed": "tsx db/seed.ts"` in package.json
  - [ ] Test seed script runs successfully: `npm run seed`

- [ ] **Update health check to verify database connection** (AC: 9)
  - [ ] Modify `app/api/health/route.ts` to include database query
  - [ ] Execute simple query: `SELECT COUNT(*) FROM team` or similar
  - [ ] Return database status in health check response: `{ status: "ok", timestamp: "...", database: "connected" }`
  - [ ] Handle database connection errors gracefully (return 503 if DB unreachable)
  - [ ] Test health check endpoint returns database connection status

- [ ] **Create database utility functions** (AC: 1, 3)
  - [ ] Create `db/client.ts` or update `db/drizzle.ts` with connection pooling config
  - [ ] Add helper functions for common queries (optional, can defer to repositories in later stories)
  - [ ] Ensure Drizzle client is exported and reusable across API routes

- [ ] **Document schema and relationships** (AC: 1, 2, 3)
  - [ ] Add JSDoc comments to schema tables explaining purpose
  - [ ] Document organizationId usage: "Unused in MVP, reserved for Phase 2 multi-tenant"
  - [ ] Create or update `docs/database-schema.md` with ER diagram or table descriptions (optional, nice-to-have)

## Dev Notes

### Previous Story Insights
Story 1.1 cleaned up starter pack and verified Drizzle ORM connection. Database connection exists but schema only contains Better Auth tables (user, session, account, verification). This story replaces/extends the schema with RunwayOKR-specific tables.

### Starter Pack Context
**Better Auth Tables to Preserve:**
The starter pack includes Better Auth 1.2.8 with the following tables (keep these in schema for Story 1.3):
- `user`: Better Auth user table (id, name, email, emailVerified, image, createdAt, updatedAt)
- `session`: Session management (id, expiresAt, token, userId, ipAddress, userAgent)
- `account`: OAuth accounts (id, accountId, providerId, userId, accessToken, refreshToken, etc.)
- `verification`: Email verification tokens (id, identifier, value, expiresAt)

**NOTE:** RunwayOKR uses a separate `okrUser` table for business logic (teams, OKR ownership) while Better Auth `user` table handles authentication. These will be linked in Story 1.3.

### Complete Database Schema
[Source: architecture/database-schema.md#Drizzle Schema Definition]

**Full schema definition for `db/schema.ts`:**

```typescript
// db/schema.ts
import { pgTable, uuid, varchar, text, boolean, timestamp, integer, numeric, date, jsonb } from 'drizzle-orm/pg-core';

// ===== Better Auth Tables (from starter pack) =====
export const user = pgTable('user', {
  id: text('id').primaryKey(),
  name: text('name').notNull(),
  email: text('email').notNull().unique(),
  emailVerified: boolean('emailVerified').notNull().default(false),
  image: text('image'),
  createdAt: timestamp('createdAt').notNull().defaultNow(),
  updatedAt: timestamp('updatedAt').notNull().defaultNow(),
});

export const session = pgTable('session', {
  id: text('id').primaryKey(),
  expiresAt: timestamp('expiresAt').notNull(),
  token: text('token').notNull().unique(),
  createdAt: timestamp('createdAt').notNull().defaultNow(),
  updatedAt: timestamp('updatedAt').notNull().defaultNow(),
  ipAddress: text('ipAddress'),
  userAgent: text('userAgent'),
  userId: text('userId')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
});

export const account = pgTable('account', {
  id: text('id').primaryKey(),
  accountId: text('accountId').notNull(),
  providerId: text('providerId').notNull(),
  userId: text('userId')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  accessToken: text('accessToken'),
  refreshToken: text('refreshToken'),
  idToken: text('idToken'),
  accessTokenExpiresAt: timestamp('accessTokenExpiresAt'),
  refreshTokenExpiresAt: timestamp('refreshTokenExpiresAt'),
  scope: text('scope'),
  password: text('password'),
  createdAt: timestamp('createdAt').notNull().defaultNow(),
  updatedAt: timestamp('updatedAt').notNull().defaultNow(),
});

export const verification = pgTable('verification', {
  id: text('id').primaryKey(),
  identifier: text('identifier').notNull(),
  value: text('value').notNull(),
  expiresAt: timestamp('expiresAt').notNull(),
  createdAt: timestamp('createdAt').notNull().defaultNow(),
  updatedAt: timestamp('updatedAt').notNull().defaultNow(),
});

// ===== RunwayOKR Business Tables =====

export const team = pgTable('team', {
  id: uuid('id').defaultRandom().primaryKey(),
  name: varchar('name', { length: 120 }).notNull(),
  organizationId: uuid('organization_id'), // Phase 2: multi-tenant
  archived: boolean('archived').notNull().default(false),
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
});

export const okrUser = pgTable('okr_user', {
  id: uuid('id').defaultRandom().primaryKey(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  name: varchar('name', { length: 120 }).notNull(),
  teamId: uuid('team_id').notNull().references(() => team.id),
  organizationId: uuid('organization_id'), // Phase 2: multi-tenant
  active: boolean('active').notNull().default(true),
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
});

export const quarter = pgTable('quarter', {
  id: uuid('id').defaultRandom().primaryKey(),
  label: varchar('label', { length: 50 }).notNull(),
  startAt: date('start_at').notNull(),
  endAt: date('end_at').notNull(),
  organizationId: uuid('organization_id'), // Phase 2: multi-tenant
  archived: boolean('archived').notNull().default(false),
  notes: text('notes'), // QBR notes (Story 3.1)
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
});

export const objective = pgTable('objective', {
  id: uuid('id').defaultRandom().primaryKey(),
  title: varchar('title', { length: 255 }).notNull(),
  teamId: uuid('team_id').notNull().references(() => team.id),
  quarterId: uuid('quarter_id').notNull().references(() => quarter.id),
  ownerId: uuid('owner_id').notNull().references(() => okrUser.id),
  organizationId: uuid('organization_id'), // Phase 2: multi-tenant
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
});

export const keyResult = pgTable('key_result', {
  id: uuid('id').defaultRandom().primaryKey(),
  title: varchar('title', { length: 500 }).notNull(),
  objectiveId: uuid('objective_id').notNull().references(() => objective.id, { onDelete: 'cascade' }),
  ownerId: uuid('owner_id').notNull().references(() => okrUser.id),
  unit: varchar('unit', { length: 5 }).notNull(), // %, pp, $, #
  direction: varchar('direction', { length: 5 }).notNull(), // up, down
  startValue: numeric('start_value', { precision: 15, scale: 2 }).notNull(),
  targetValue: numeric('target_value', { precision: 15, scale: 2 }).notNull(),
  currentValue: numeric('current_value', { precision: 15, scale: 2 }).notNull(),
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
});

export const checkIn = pgTable('check_in', {
  id: uuid('id').defaultRandom().primaryKey(),
  krId: uuid('kr_id').notNull().references(() => keyResult.id, { onDelete: 'cascade' }),
  value: numeric('value', { precision: 15, scale: 2 }).notNull(),
  confidence: integer('confidence').notNull(), // 0=Red, 1=Amber, 2=Green
  note: varchar('note', { length: 500 }),
  createdBy: uuid('created_by').notNull().references(() => okrUser.id),
  createdAt: timestamp('created_at').notNull().defaultNow(),
});

export const importRecord = pgTable('import_record', {
  id: uuid('id').defaultRandom().primaryKey(),
  filename: varchar('filename', { length: 255 }).notNull(),
  rowCount: integer('row_count').notNull(),
  createdBy: uuid('created_by').notNull().references(() => okrUser.id),
  createdAt: timestamp('created_at').notNull().defaultNow(),
  metadata: jsonb('metadata'),
});
```

**Performance Indexes to Add:**
[Source: architecture/database-schema.md#Indexes for Performance]

Add these indexes for query performance (use Drizzle `index()` helper or raw SQL in migration):
- `team_org_idx`: team(organization_id)
- `user_team_idx`: okr_user(team_id)
- `obj_quarter_idx`: objective(quarter_id)
- `obj_team_idx`: objective(team_id)
- `kr_obj_idx`: key_result(objective_id)
- `kr_owner_idx`: key_result(owner_id)
- `checkin_kr_idx`: check_in(kr_id)
- `checkin_created_idx`: check_in(created_at)

### TypeScript Type Definitions
[Source: architecture/data-models.md]

**Create type aliases for enums and models:**

```typescript
// types/database.ts or db/types.ts
import { InferSelectModel, InferInsertModel } from 'drizzle-orm';
import * as schema from '@/db/schema';

// Enum types
export type Unit = '%' | 'pp' | '$' | '#';
export type Direction = 'up' | 'down';
export type ConfidenceLevel = 0 | 1 | 2; // Red=0, Amber=1, Green=2

// Table types
export type Team = InferSelectModel<typeof schema.team>;
export type OkrUser = InferSelectModel<typeof schema.okrUser>;
export type Quarter = InferSelectModel<typeof schema.quarter>;
export type Objective = InferSelectModel<typeof schema.objective>;
export type KeyResult = InferSelectModel<typeof schema.keyResult>;
export type CheckIn = InferSelectModel<typeof schema.checkIn>;
export type ImportRecord = InferSelectModel<typeof schema.importRecord>;

// Insert types (for creation)
export type NewTeam = InferInsertModel<typeof schema.team>;
export type NewOkrUser = InferInsertModel<typeof schema.okrUser>;
export type NewQuarter = InferInsertModel<typeof schema.quarter>;
export type NewObjective = InferInsertModel<typeof schema.objective>;
export type NewKeyResult = InferInsertModel<typeof schema.keyResult>;
export type NewCheckIn = InferInsertModel<typeof schema.checkIn>;
export type NewImportRecord = InferInsertModel<typeof schema.importRecord>;
```

### Seed Data Specification
[Source: PRD Epic 1 Story 1.2 AC#8, FR17]

**Seed script should create:**

**Teams (2):**
1. Direct Channel Sales
2. Corporate Sales

**Users (5):**
1. Sarah Chen (sarah.chen@airline.com) - Direct Channel Sales team - Executive
2. Mike Johnson (mike.johnson@airline.com) - Direct Channel Sales team - KR Owner
3. Lisa Wang (lisa.wang@airline.com) - Corporate Sales team - Team Lead
4. James Rodriguez (james.rodriguez@airline.com) - Corporate Sales team - KR Owner
5. Emily Davis (emily.davis@airline.com) - Corporate Sales team - KR Owner

**Quarter (1):**
- Label: "2025-Q1"
- Start: 2025-01-01
- End: 2025-03-31

**Objectives (3) with Key Results (10 total):**

**Objective 1: "Grow Direct Channel Revenue" (Direct Channel Sales, Owner: Sarah Chen)**
1. KR: "Increase direct booking conversion rate from 2.8% to 3.5%" - Unit: %, Direction: up, Start: 2.8, Target: 3.5, Owner: Mike Johnson
2. KR: "Grow mobile app bookings from $12M to $18M" - Unit: $, Direction: up, Start: 12000000, Target: 18000000, Owner: Mike Johnson
3. KR: "Reduce third-party commission costs from 15% to 12%" - Unit: pp, Direction: down, Start: 15, Target: 12, Owner: Sarah Chen

**Objective 2: "Expand Corporate Sales in APAC" (Corporate Sales, Owner: Lisa Wang)**
1. KR: "Sign 25 new corporate accounts (baseline: 0)" - Unit: #, Direction: up, Start: 0, Target: 25, Owner: James Rodriguez
2. KR: "Increase APAC corporate revenue from $8M to $15M" - Unit: $, Direction: up, Start: 8000000, Target: 15000000, Owner: Lisa Wang
3. KR: "Achieve 85% contract renewal rate (baseline: 70%)" - Unit: %, Direction: up, Start: 70, Target: 85, Owner: Emily Davis
4. KR: "Reduce average sales cycle from 90 to 60 days" - Unit: #, Direction: down, Start: 90, Target: 60, Owner: James Rodriguez

**Objective 3: "Increase Loyalty Co-brand Revenue" (Direct Channel Sales, Owner: Sarah Chen)**
1. KR: "Grow co-brand credit card sign-ups from 5,000 to 8,000 per month" - Unit: #, Direction: up, Start: 5000, Target: 8000, Owner: Mike Johnson
2. KR: "Increase loyalty member redemption rate from 18% to 25%" - Unit: %, Direction: up, Start: 18, Target: 25, Owner: Sarah Chen
3. KR: "Boost partner airline bookings from $3M to $5M" - Unit: $, Direction: up, Start: 3000000, Target: 5000000, Owner: Mike Johnson

**Check-ins (2-3 per KR):**
Add 2-3 initial check-ins per KR with realistic progress (e.g., Week 1, Week 2, Week 3 data) to populate sparkline charts. Use confidence levels: 0 (Red), 1 (Amber), 2 (Green) based on progress.

### Data Models Reference
[Source: architecture/data-models.md]

Refer to complete data model documentation for:
- Field constraints and validation rules
- Relationship cardinality (1:many, many:1)
- Business logic (confidence rollup, progress calculation)
- Computed fields (not stored in DB)

Key relationships:
- `okrUser` belongs to `team` (1:many)
- `objective` belongs to `team`, `quarter`, `okrUser` owner (many:1 each)
- `keyResult` belongs to `objective`, `okrUser` owner (many:1 each)
- `checkIn` belongs to `keyResult`, `okrUser` creator (many:1 each)

### Multi-Tenant Architecture Note
[Source: PRD NFR17]

**organizationId columns:**
All tables with `organizationId` follow NFR17: "Single-tenant database architecture with schema designed for future multi-tenant migration."

- In MVP: `organizationId` is nullable and unused (set to NULL for all records)
- Phase 2: Will be populated with organization UUID, indexed, and used for row-level security
- Do NOT implement organization logic in this story—just include the column

### Drizzle Migration Commands
[Source: architecture/tech-stack.md#ORM]

**Generate migrations:**
```bash
npx drizzle-kit generate:pg
```

**Apply migrations to database:**
```bash
npx drizzle-kit push:pg
```

**Verify migration:**
Check Neon dashboard or run SQL query:
```sql
SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';
```

### Health Check Update
[Source: Story 1.1, architecture/backend-architecture.md]

Update `app/api/health/route.ts` to verify database connection:

```typescript
import { db } from '@/db/drizzle';
import { team } from '@/db/schema';

export async function GET() {
  try {
    // Simple query to verify DB connection
    const result = await db.select().from(team).limit(1);

    return Response.json({
      status: "ok",
      timestamp: new Date().toISOString(),
      database: "connected"
    }, { status: 200 });
  } catch (error) {
    return Response.json({
      status: "error",
      timestamp: new Date().toISOString(),
      database: "disconnected",
      error: error.message
    }, { status: 503 });
  }
}
```

### Testing
[Source: architecture/testing-strategy.md#Testing Pyramid]

**For This Story:**
- Manual verification: Query Neon database to verify tables exist
- Run seed script: `npm run seed` should populate database without errors
- Test health check: GET `/api/health` should return `database: "connected"`
- Visual verification: Use Neon dashboard to inspect table structure and seed data

**Future Testing:**
- Integration tests for seed script (verify counts match expected)
- Schema validation tests (ensure all FKs and constraints work)
- Defer to later stories when test infrastructure is fully set up

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-06 | 1.0 | Initial story creation with complete schema, seed data spec, and Better Auth integration | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by Dev Agent during implementation_

### Debug Log References
_To be populated by Dev Agent during implementation_

### Completion Notes List
_To be populated by Dev Agent during implementation_

### File List
_To be populated by Dev Agent during implementation_

## QA Results
_To be populated by QA Agent after story completion_
